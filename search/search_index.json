{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dolo Introduction Dolo is a tool to describe and solve economic models. It provides a simple classification scheme to describe many types of models, allows to write the models as simple text files and compiles these files into efficient Python objects representing them. It also provides many reference solution algorithms to find the solution of these models under rational expectations. Dolo understand several types of nonlinear models with occasionnally binding constraints (with or without exogenous discrete shocks), as well as local pertubations models, like Dynare. It is a very adequate tool to study zero-lower bound issues, or sudden-stop problems, for instance. Sophisticated solution routines are available: local perturbations up to third order, perfect foresight solution, policy iteration, value iteration. Most of these solutions are either parallelized or vectorized. They are written in pure Python, and can easily be inspected or adapted. Thanks to the simple and consistent Python API for models, it is possible to write models in pure Python, or to implement other solution algorithms on top it. Frequently Asked Questions No question was ever asked. Certainly because it's all very clear.","title":"Home"},{"location":"#dolo","text":"","title":"Dolo"},{"location":"#introduction","text":"Dolo is a tool to describe and solve economic models. It provides a simple classification scheme to describe many types of models, allows to write the models as simple text files and compiles these files into efficient Python objects representing them. It also provides many reference solution algorithms to find the solution of these models under rational expectations. Dolo understand several types of nonlinear models with occasionnally binding constraints (with or without exogenous discrete shocks), as well as local pertubations models, like Dynare. It is a very adequate tool to study zero-lower bound issues, or sudden-stop problems, for instance. Sophisticated solution routines are available: local perturbations up to third order, perfect foresight solution, policy iteration, value iteration. Most of these solutions are either parallelized or vectorized. They are written in pure Python, and can easily be inspected or adapted. Thanks to the simple and consistent Python API for models, it is possible to write models in pure Python, or to implement other solution algorithms on top it.","title":"Introduction"},{"location":"#frequently-asked-questions","text":"No question was ever asked. Certainly because it's all very clear.","title":"Frequently Asked Questions"},{"location":"installation/","text":"Basic installation Dolo can be installed in several ways: with anaconda (recommended): conda install -c conda-forge dolo with pip pip install dolo Developper's installation Dolo uses poetry as package manager, so you probably need to install poetry before you start developing the package.","title":"Install"},{"location":"installation/#basic-installation","text":"Dolo can be installed in several ways: with anaconda (recommended): conda install -c conda-forge dolo with pip pip install dolo","title":"Basic installation"},{"location":"installation/#developpers-installation","text":"Dolo uses poetry as package manager, so you probably need to install poetry before you start developing the package.","title":"Developper's installation"},{"location":"model_api/","text":"Model API For numerical purposes, models are essentially represented as a set of symbols, calibration and functions representing the various equation types of the model. This data is held in a Model object whose API is described in this chapter. Models are usually created by writing a Yaml files as described in the the previous chapter, but as we will see below, they can also be written directly as long as they satisfy the requirements detailed below. Model Object As previously, let\\'s consider, the Real Business Cycle example, from the introduction. The model object can be created using the yaml file: model = yaml_import ( 'models/rbc.yaml' ) The object contains few meta-data: display( model.name ) # -> Real Business Cycles display( model.model_type ) # -> `dtcc` Note model_type field is now always dtcc . Older model types ( 'dtmscc' , 'dtcscc' , 'dynare' ) are not used anymore. Calibration Each models stores calibration information as model.calibration . It is a special dictionary-like object, which contains calibration information, that is values for parameters and initial values (or steady-state) for all other variables of the model. It is possible to retrieve one or several variables calibrations: display ( model . calibration [ 'k' ] ) # -> 2.9 display ( model . calibration [ 'k' , 'delta' ] # -> [2.9, 0.08] When a key coresponds to one of the symbols group, one gets one or several vectors of variables instead: model . calibration [ 'states' ] # - > np.array([2.9, 0]) (values of states [z, k]) model . calibration [ 'states' , 'controls' ] # -> [np.array([2.9, 0]), np.array([0.29, 1.0])] To get regular dictionary mapping states groups and vectors, one can use the attributed .grouped The values are vectors (1d numpy arrays) of values for each symbol group. For instance the following code will print the calibrated values of the parameters: for ( variable_group , variables ) in model . calibration . items (): print ( variables_group , variables ) In order to get a (key,values) of all the values of the model, one can call model.calibration.flat . for ( variable_group , variables ) in model . calibration . items (): print ( variables_group , variables ) Note The calibration object can contain values that are not symbols of the model. These values can be used to calibrate model parameters and are also evaluated in the other yaml sections, using the supplied value. One uses the model.set_calibration() routine to change the calibration of the model. This one takes either a dict as an argument, or a set of keyword arguments. Both calls are valid: model . set_calibration ( { 'delta' : 0.01 } ) model . set_calibration ( { 'i' : 'delta*k' } ) model . set_calibration ( delta = 0.08 , k = 2.8 ) This method also understands symbolic expressions (as string) which makes it possible to define symbols as a function of other symbols: model . set_calibration ( beta = '1/(1+delta)' ) print ( model . get_calibration ( 'beta' )) # -> nan model . set_calibration ( delta = 0.04 ) print ( model . get_calibration ([ 'beta' , 'delta' ])) # -> [0.96, 0.04] Under the hood, the method stores the symbolic relations between symbols. It is precisely equivalent to use the set_calibration method or to change the values in the yaml files. In particular, the calibration order is irrelevant as long as all parameters can be deduced one from another. Functions A model of a specific type can feature various kinds of functions. For instance, a continuous-states-continuous-controls models, solved by iterating on the Euler equations may feature a transition equation g g and an arbitrage equation f f . Their signature is respectively s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) and E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] , where s_t s_t , x_t x_t and e_t e_t respectively represent a vector of states, controls and exogenous shock. Implicitly, all functions are also assumed to depend on the vector of parameters :math: p . These functions can be accessed by their type in the model.functions dictionary: g = model . functions [ 'transition' ] f = model . functions [ 'arbitrage' ] Let's call the arbitrage function on the steady-state value, to see the residuals at the deterministic steady-state: m = model . calibration [ 'exogenous' ] s = model . calibration [ 'states' ] x = model . calibration [ 'controls' ] p = model . calibration [ 'parameters' ] res = f ( m , s , x , m , s , x , p ) display ( res ) The output ( res ) is two element vector, representing the residuals of the two arbitrage equations at the steady-state. It should be full of zero. Is it ? Great ! By inspecting the arbitrage function ( f? ), one can see that its call api is: f ( m , s , x , M , S , X , p , diff = False , out = None ) Since m , s and x are the short names for exogenous shocks, states and controls, their values at date t+1 t+1 is denoted with S and X . This simple convention prevails in most of dolo source code: when possible, vectors at date t are denoted with lowercase, while future vectors are with upper case. We have already commented the presence of the parameter vector p . Now, the generated functions also gives the option to perform in place computations, when an output vector is given: out = numpy . ones ( 2 ) f ( m , s , x , m , s , x , p , out ) # out now contains zeros It is also possible to compute derivatives of the function by setting diff=True . In that case, the residual and jacobians with respect to the various arguments are returned as a list: r , r_m , r_s , r_x , r_M , r_S , r_X = f ( m , s , x , m , s , x , p , diff = True ) Since there are two states and two controls, the variables r_s, r_x, r_S, r_X are all 2 by 2 matrices. The generated functions also allow for efficient vectorized evaluation. In order to evaluate the residuals :math: N times, one needs to supply matrix arguments, instead of vectors, so that each line corresponds to one value to evaluate as in the following example: N = 10000 vec_m = m [ None ,:] . repeat ( N , axis = 0 ) # we repeat each line N times vec_s = s [ None ,:] . repeat ( N , axis = 0 ) # we repeat each line N times vec_x = x [ None ,:] . repeat ( N , axis = 0 ) vec_X = X [ None ,:] . repeat ( N , axis = 0 ) vec_p = p [ None ,:] . repeat ( N , axis = 0 ) # actually, except for vec_s, the function repeat is not need since broadcast rules apply vec_s [:, 0 ] = linspace ( 2 , 4 , N ) # we provide various guesses for the steady-state capital vec_S = vec_s out = f ( vec_m , vec_s , vec_x , vec_M , vec_S , vec_X , vec_p ) # now a 10000 x 2 array out , out_m , out_s , out_x , out_M , out_S , out_X = f ( vec_m , vec_s , vec_x , vec_m , vec_S , vec_X , vec_p ) The vectorized evaluation is optimized so that it is much faster to make a vectorized call rather than iterate on each point. Note In the preceding example, the parameters are constant for all evaluations, yet they are repeated. This is not mandatory, and the call f(vec_m, vec_s, vec_x, vec_M, vec_S, vec_X, p) should work exactly as if p had been repeated along the first axis. We follow there numba's guvectorize conventions, even though they slightly differ from numpy's ones. Exogenous shock The exogenous field contains information about the driving process. To get its default, discretized version, one can call model.exogenous.discretize() . Options structure The model.options structure holds an information required by a particular solution method. For instance, for global methods, model.options['grid'] is supposed to hold the boundaries and the number nodes at which to interpolate. display ( model . options [ 'grid' ] )","title":"Model API"},{"location":"model_api/#model-api","text":"For numerical purposes, models are essentially represented as a set of symbols, calibration and functions representing the various equation types of the model. This data is held in a Model object whose API is described in this chapter. Models are usually created by writing a Yaml files as described in the the previous chapter, but as we will see below, they can also be written directly as long as they satisfy the requirements detailed below.","title":"Model API"},{"location":"model_api/#model-object","text":"As previously, let\\'s consider, the Real Business Cycle example, from the introduction. The model object can be created using the yaml file: model = yaml_import ( 'models/rbc.yaml' ) The object contains few meta-data: display( model.name ) # -> Real Business Cycles display( model.model_type ) # -> `dtcc` Note model_type field is now always dtcc . Older model types ( 'dtmscc' , 'dtcscc' , 'dynare' ) are not used anymore.","title":"Model Object"},{"location":"model_api/#calibration","text":"Each models stores calibration information as model.calibration . It is a special dictionary-like object, which contains calibration information, that is values for parameters and initial values (or steady-state) for all other variables of the model. It is possible to retrieve one or several variables calibrations: display ( model . calibration [ 'k' ] ) # -> 2.9 display ( model . calibration [ 'k' , 'delta' ] # -> [2.9, 0.08] When a key coresponds to one of the symbols group, one gets one or several vectors of variables instead: model . calibration [ 'states' ] # - > np.array([2.9, 0]) (values of states [z, k]) model . calibration [ 'states' , 'controls' ] # -> [np.array([2.9, 0]), np.array([0.29, 1.0])] To get regular dictionary mapping states groups and vectors, one can use the attributed .grouped The values are vectors (1d numpy arrays) of values for each symbol group. For instance the following code will print the calibrated values of the parameters: for ( variable_group , variables ) in model . calibration . items (): print ( variables_group , variables ) In order to get a (key,values) of all the values of the model, one can call model.calibration.flat . for ( variable_group , variables ) in model . calibration . items (): print ( variables_group , variables ) Note The calibration object can contain values that are not symbols of the model. These values can be used to calibrate model parameters and are also evaluated in the other yaml sections, using the supplied value. One uses the model.set_calibration() routine to change the calibration of the model. This one takes either a dict as an argument, or a set of keyword arguments. Both calls are valid: model . set_calibration ( { 'delta' : 0.01 } ) model . set_calibration ( { 'i' : 'delta*k' } ) model . set_calibration ( delta = 0.08 , k = 2.8 ) This method also understands symbolic expressions (as string) which makes it possible to define symbols as a function of other symbols: model . set_calibration ( beta = '1/(1+delta)' ) print ( model . get_calibration ( 'beta' )) # -> nan model . set_calibration ( delta = 0.04 ) print ( model . get_calibration ([ 'beta' , 'delta' ])) # -> [0.96, 0.04] Under the hood, the method stores the symbolic relations between symbols. It is precisely equivalent to use the set_calibration method or to change the values in the yaml files. In particular, the calibration order is irrelevant as long as all parameters can be deduced one from another.","title":"Calibration"},{"location":"model_api/#functions","text":"A model of a specific type can feature various kinds of functions. For instance, a continuous-states-continuous-controls models, solved by iterating on the Euler equations may feature a transition equation g g and an arbitrage equation f f . Their signature is respectively s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) and E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] , where s_t s_t , x_t x_t and e_t e_t respectively represent a vector of states, controls and exogenous shock. Implicitly, all functions are also assumed to depend on the vector of parameters :math: p . These functions can be accessed by their type in the model.functions dictionary: g = model . functions [ 'transition' ] f = model . functions [ 'arbitrage' ] Let's call the arbitrage function on the steady-state value, to see the residuals at the deterministic steady-state: m = model . calibration [ 'exogenous' ] s = model . calibration [ 'states' ] x = model . calibration [ 'controls' ] p = model . calibration [ 'parameters' ] res = f ( m , s , x , m , s , x , p ) display ( res ) The output ( res ) is two element vector, representing the residuals of the two arbitrage equations at the steady-state. It should be full of zero. Is it ? Great ! By inspecting the arbitrage function ( f? ), one can see that its call api is: f ( m , s , x , M , S , X , p , diff = False , out = None ) Since m , s and x are the short names for exogenous shocks, states and controls, their values at date t+1 t+1 is denoted with S and X . This simple convention prevails in most of dolo source code: when possible, vectors at date t are denoted with lowercase, while future vectors are with upper case. We have already commented the presence of the parameter vector p . Now, the generated functions also gives the option to perform in place computations, when an output vector is given: out = numpy . ones ( 2 ) f ( m , s , x , m , s , x , p , out ) # out now contains zeros It is also possible to compute derivatives of the function by setting diff=True . In that case, the residual and jacobians with respect to the various arguments are returned as a list: r , r_m , r_s , r_x , r_M , r_S , r_X = f ( m , s , x , m , s , x , p , diff = True ) Since there are two states and two controls, the variables r_s, r_x, r_S, r_X are all 2 by 2 matrices. The generated functions also allow for efficient vectorized evaluation. In order to evaluate the residuals :math: N times, one needs to supply matrix arguments, instead of vectors, so that each line corresponds to one value to evaluate as in the following example: N = 10000 vec_m = m [ None ,:] . repeat ( N , axis = 0 ) # we repeat each line N times vec_s = s [ None ,:] . repeat ( N , axis = 0 ) # we repeat each line N times vec_x = x [ None ,:] . repeat ( N , axis = 0 ) vec_X = X [ None ,:] . repeat ( N , axis = 0 ) vec_p = p [ None ,:] . repeat ( N , axis = 0 ) # actually, except for vec_s, the function repeat is not need since broadcast rules apply vec_s [:, 0 ] = linspace ( 2 , 4 , N ) # we provide various guesses for the steady-state capital vec_S = vec_s out = f ( vec_m , vec_s , vec_x , vec_M , vec_S , vec_X , vec_p ) # now a 10000 x 2 array out , out_m , out_s , out_x , out_M , out_S , out_X = f ( vec_m , vec_s , vec_x , vec_m , vec_S , vec_X , vec_p ) The vectorized evaluation is optimized so that it is much faster to make a vectorized call rather than iterate on each point. Note In the preceding example, the parameters are constant for all evaluations, yet they are repeated. This is not mandatory, and the call f(vec_m, vec_s, vec_x, vec_M, vec_S, vec_X, p) should work exactly as if p had been repeated along the first axis. We follow there numba's guvectorize conventions, even though they slightly differ from numpy's ones.","title":"Functions"},{"location":"model_api/#exogenous-shock","text":"The exogenous field contains information about the driving process. To get its default, discretized version, one can call model.exogenous.discretize() .","title":"Exogenous shock"},{"location":"model_api/#options-structure","text":"The model.options structure holds an information required by a particular solution method. For instance, for global methods, model.options['grid'] is supposed to hold the boundaries and the number nodes at which to interpolate. display ( model . options [ 'grid' ] )","title":"Options structure"},{"location":"processes/","text":"Shocks The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks aka distributions continuous auto-correlated process such as AR1 discrete processes such as discrete markov chains Exogenous shock processes are specified in the section exogenous of a yaml file. Here are some examples for each type of shock: Distributions / IIDProcess Univariate distributions IID Normal The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu IID LogNormal Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu Uniform Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max Beta If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1 Bernouilli Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3 Multivariate distributions Normal (multivariate) Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1] Mixtures For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. exogenous : !Mixture index : !Bernouilli p : 0.3 distributions : 0 : UNormal(\u03bc=0.0, \u03c3=0.01) 1 : UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. exogenous : e,v : !Mixture : index : !Bernouilli p : 0.3 distributions : 0 : Constant(\u03bc=[0.1, 0.2]) 1 : Constant(\u03bc=[0.2, 0.3]) Continuous Autoregressive Process AR1 / VAR1 For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous : !AR1 rho : 0.9 Sigma : [[ \u03c3^2 ]] Markov chains Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous : !MarkovChain values : [[ -0.01 , 0.1 ],[ 0.01 , 0.1 ]] transitions : [[ 0.9 , 0.1 ], [ 0.1 , 0.9 ]] Product We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof). Conditional processes Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Discretization methods for continous shocks To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Shocks"},{"location":"processes/#shocks","text":"The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks aka distributions continuous auto-correlated process such as AR1 discrete processes such as discrete markov chains Exogenous shock processes are specified in the section exogenous of a yaml file. Here are some examples for each type of shock:","title":"Shocks"},{"location":"processes/#distributions-iidprocess","text":"","title":"Distributions / IIDProcess"},{"location":"processes/#univariate-distributions","text":"","title":"Univariate distributions"},{"location":"processes/#iid-normal","text":"The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu","title":"IID Normal"},{"location":"processes/#iid-lognormal","text":"Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu","title":"IID LogNormal"},{"location":"processes/#uniform","text":"Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max","title":"Uniform"},{"location":"processes/#beta","text":"If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1","title":"Beta"},{"location":"processes/#bernouilli","text":"Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3","title":"Bernouilli"},{"location":"processes/#multivariate-distributions","text":"","title":"Multivariate distributions"},{"location":"processes/#normal-multivariate","text":"Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1]","title":"Normal (multivariate)"},{"location":"processes/#mixtures","text":"For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. exogenous : !Mixture index : !Bernouilli p : 0.3 distributions : 0 : UNormal(\u03bc=0.0, \u03c3=0.01) 1 : UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. exogenous : e,v : !Mixture : index : !Bernouilli p : 0.3 distributions : 0 : Constant(\u03bc=[0.1, 0.2]) 1 : Constant(\u03bc=[0.2, 0.3])","title":"Mixtures"},{"location":"processes/#continuous-autoregressive-process","text":"","title":"Continuous Autoregressive Process"},{"location":"processes/#ar1-var1","text":"For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous : !AR1 rho : 0.9 Sigma : [[ \u03c3^2 ]]","title":"AR1 / VAR1"},{"location":"processes/#markov-chains","text":"Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous : !MarkovChain values : [[ -0.01 , 0.1 ],[ 0.01 , 0.1 ]] transitions : [[ 0.9 , 0.1 ], [ 0.1 , 0.9 ]]","title":"Markov chains"},{"location":"processes/#product","text":"We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof).","title":"Product"},{"location":"processes/#conditional-processes","text":"Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]]","title":"Conditional processes"},{"location":"processes/#discretization-methods-for-continous-shocks","text":"To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Discretization methods for continous shocks"},{"location":"shocks/","text":"Shocks The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks continuous auto-correlated process discrete markov chain. Exogenous shock processes are specified in the section exogenous of a yaml file.. Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Here are some examples for each type of shock: IID Distributions Univariate distributions IID Normal The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted, thanks to the greek_tolerance function. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu IID LogNormal Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu Uniform Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max Beta If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1 Bernouilli Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3 Multivariate distributions Normal (multivariate) Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1] Mixtures For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. ... exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3]) Continuous Autoregressive Process AR1 / VAR1 For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]] Markov chains Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] Product We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: ``` symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu ``` In this case we define several shocks for several variables (or combinations thereof). Conditional processes Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Discretization methods for continous shocks To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Shocks"},{"location":"shocks/#shocks","text":"The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks continuous auto-correlated process discrete markov chain. Exogenous shock processes are specified in the section exogenous of a yaml file.. Dolo accepts various exogenous processes such as normally distributed iid shocks, VAR1 processes, and Markov Chain processes. Here are some examples for each type of shock:","title":"Shocks"},{"location":"shocks/#iid-distributions","text":"","title":"IID Distributions"},{"location":"shocks/#univariate-distributions","text":"","title":"Univariate distributions"},{"location":"shocks/#iid-normal","text":"The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted, thanks to the greek_tolerance function. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu","title":"IID Normal"},{"location":"shocks/#iid-lognormal","text":"Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu","title":"IID LogNormal"},{"location":"shocks/#uniform","text":"Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max","title":"Uniform"},{"location":"shocks/#beta","text":"If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1","title":"Beta"},{"location":"shocks/#bernouilli","text":"Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3","title":"Bernouilli"},{"location":"shocks/#multivariate-distributions","text":"","title":"Multivariate distributions"},{"location":"shocks/#normal-multivariate","text":"Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1]","title":"Normal (multivariate)"},{"location":"shocks/#mixtures","text":"For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. ... exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3])","title":"Mixtures"},{"location":"shocks/#continuous-autoregressive-process","text":"","title":"Continuous Autoregressive Process"},{"location":"shocks/#ar1-var1","text":"For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]]","title":"AR1 / VAR1"},{"location":"shocks/#markov-chains","text":"Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]]","title":"Markov chains"},{"location":"shocks/#product","text":"We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: ``` symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu ``` In this case we define several shocks for several variables (or combinations thereof).","title":"Product"},{"location":"shocks/#conditional-processes","text":"Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]]","title":"Conditional processes"},{"location":"shocks/#discretization-methods-for-continous-shocks","text":"To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Discretization methods for continous shocks"}]}